package backtrack.algorithm;
/*
    【37 解数独】 编写一个程序，通过填充空格来解决数独问题。
                数独的解法需 遵循如下规则：

                数字 1-9 在每一行只能出现一次。
                数字 1-9 在每一列只能出现一次。
                数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。（请参考示例图）
                数独部分空格内已填入了数字，空白格用 '.' 表示。

                5 3 .   . 7 .   . . .
                6 . .   1 9 5   . . .
                . 9 8   . . .   . 6 .

                8 . .   . 6 .   . . 3
                4 . .   8 . 3   . . 1
                7 . .   . 2 .   . . 6

                . 6 .   . . .   2 8 .
                . . .   4 1 9   . . 5
                . . .   . 8 .   . 7 9

    输入：board = [["5","3",".",".","7",".",".",".","."],
                  ["6",".",".","1","9","5",".",".","."],
                  [".","9","8",".",".",".",".","6","."],
                  ["8",".",".",".","6",".",".",".","3"],
                  ["4",".",".","8",".","3",".",".","1"],
                  ["7",".",".",".","2",".",".",".","6"],
                  [".","6",".",".",".",".","2","8","."],
                  [".",".",".","4","1","9",".",".","5"],
                  [".",".",".",".","8",".",".","7","9"]]
    输出：[["5","3","4","6","7","8","9","1","2"],
          ["6","7","2","1","9","5","3","4","8"],
          ["1","9","8","3","4","2","5","6","7"],
          ["8","5","9","7","6","1","4","2","3"],
          ["4","2","6","8","5","3","7","9","1"],
          ["7","1","3","9","2","4","8","5","6"],
          ["9","6","1","5","3","7","2","8","4"],
          ["2","8","7","4","1","9","6","3","5"],
          ["3","4","5","2","8","6","1","7","9"]]

    ====================================================================================
    【解题思路】二维递归：确定行 + 列 + 依次在指定位置递归的放入 1 - 9
             1、双重 for 递归：因为 行 和 列 需要确定
             2、确定回溯终止条件：当找到一个满足要求的棋盘，则终止
             3、如何实现 当找到一个满足要求的棋盘，则终止？ 回溯函数的返回值，需要回溯函数的返回值定义为 布尔 类型
                针对不需要完全搜索整棵树的操作，只需要在树中找到一个符合条件的结果就返回的情况，可以将回溯函数返回值 定义为 布尔类型
 */
public class SolveSudoku {
    public void solveSudoku(char[][] board) {
         backTracking(board);
    }

    private boolean backTracking(char[][] board) {
        // 选行
        for (int i = 0; i < board.length; i++) {
            // 选列
            for (int j = 0; j < board[0].length; j++) {
                // 找到可以放数字的位置
                if (board[i][j] == '.'){
                    // 放数字
                    for (char k = '1'; k <= '9' ; k++) {
                        // 判断放置数字的合法性
                        if(valid(i, j, k, board)){
                            board[i][j] = k;
                            // 递归
                            boolean b = backTracking(board);
                            // 如果返回 true，证明已经找到结果，不再需要继续搜索
                            if (b)
                                return true;
                            // 如果返回 false，需要继续回溯，继续搜索
                            board[i][j] = '.';
                        }
                    }
                    // 数字放完之后，还没有返回true，证明可能是个按规则无法填满棋盘
                    return false;
                }
            }
        }
        // 遍历完棋盘填满数组前都没有返回 false，证明找到了答案
        return true;
    }

    private boolean valid(int i, int j, char k, char[][] board) {
        // 同一行不能出现 k
        for (int c = 0; c < board[0].length; c++) {
            if (board[i][c] == k)
                return false;
        }
        // 同一列不能出现 k
        for (int l = 0; l < board.length; l++) {
            if (board[l][j] == k)
                return false;
        }
        // 九宫格不能出现 k
        // 求 k 所在九宫格的起始位置
        int rowStart = (i / 3) * 3;
        int columnStart = (j / 3) * 3;
        for (int row = rowStart; row < rowStart + 3; row++) {
            for (int column = columnStart; column < columnStart + 3; column++) {
                if (board[row][column] == k)
                    return false;
            }
        }
        return true;
    }
}
