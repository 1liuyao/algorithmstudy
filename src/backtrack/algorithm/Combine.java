package backtrack.algorithm;
/*
    【77 组合】：给定两个整数 n 和 k，返回范围 [1, n] 中所有可能的 k 个数的组合。
               你可以按 任何顺序 返回答案。
               本题目其实就是在模拟数学组合公式C(n,k)的过程，即n个数中任取k个数

    【用例1】
            输入：n = 4, k = 2
            输出：
            [
              [2,4],
              [3,4],
              [2,3],
              [1,2],
              [1,3],
              [1,4],
            ]
     【用例2】
            输入：n = 1, k = 1
            输出：[[1]]
     ==================================================================
     【解题思路】回溯法：本质是暴力搜索的全部的情况，是【递归】的返回过程，
                     就像我们深度遍历左子树时，遍历到叶子结点后，逐步回退到根节点的过程，就叫【回溯】。
                     因此，【递归的下面就是回溯的过程】，递归就像方法依次入栈的过程，回溯就像方法执行完依次出现的过程
     【举例】先考虑一种简单情况，[1 2 3 4] n = 4 k = 2,预期结果应为[[1 2] [1 3] [1 4] [2 3] [2 4] [3 4]]
     【注意】1、组合：是无序的，认为[1 2]和[2 1]是同一个元素
           2、排列：是有序的，认为[1 2]和[2 1]是同两个元素
     【for循环方案】for(i = 0; i < array.length; i++){
                       // 注意：这里j从i+1开始，因为是组合，取过的元素不需要排序，同时自身不和自身组合，即[1 1]非法
                       for(j = i + 1; i < array.length; i++){
                            System.out.println("[" + i + " " + j + "]");
                       }
                  }
     【问题】考虑如果数组很大，有50个元素，k = 50，那么就需要嵌套50层for循环
     【如何解决 k 层循环嵌套的问题】递归方式

     【递归三步曲】1、确定递归函数的形参和返回值：
                  （1）形参：通常对应for循环中不断迭代更新的变量，如循环变量i j
                  （2）返回值：通常考虑上一层需要下一层给什么数据，如果这个数据被收集在数组中或其他容器，
                             那么可以直接return结束，不需要返回具体的值
                   ※注意：这个用于收集中间结果的容器可以定义成全局变量，或者作为递归参数进行传递
                2、确定递归的终止条件：递归是纵向的，走到叶子结点就是中点
                3、确定单层递归的逻辑：通常对应for循环中除去循环变量，如：i++,j++后，剩余的那部分【固定操作】逻辑

     【回溯三步曲】：1、回溯是依赖递归存在的，所以步骤和递归基本一摸一样，不同点在于需要在递归下面的代码添加回溯操作
                  2、回溯一般都是在【集合中递归搜索】，集合的大小构成树的宽度，递归的深度构成了树的深度
                  3、回溯方法适合解决：（1）组合问题：如何按照一定规则在 N 个数中找出 K 个数的集合，即数学公式C(n,k)
                                   （2）排列问题：N个数按照一定规则全排列，有几种排列方式
                                   （3）切割问题：一个字符串按照一定规则切割，有几种切割方式
                                   （4）子集问题：一个N个数的集合中有多少符合条件的子集
                                   （5）棋盘问题：N皇后，数独等问题
                  4、回溯问题都可以转成一个形象的描述成一棵树，叶子结点保存的值就是最终的结果，
                     到达叶子结点的路径描述了从根到达叶子结点的一系列操作，这个操作在层与层之间是重复的
                  5、回溯模板
                    // 定义收集结果的容器（全局变量）
                    void backTracking(参数){                                          1、确定回溯函数的形参和返回值
                    =================================================================================================
                        if (终止条件){
                            容器收集结果;                                              2、确定回溯函数终止条件并收集结果
                            return;
                        }
                    ================================================================================================
                        for(选择：本层集合中的元素（树中结点孩子的数量就是集合的大小）){       3、确定回溯搜索遍历的过程：
                            处理结点;                                                      for循环是【本层】横向遍历集合
                            backTracking(路径，选择列表); // 递归的过程 == 树深度遍历的过程      递归是本层操作执行完，准备向下一层遍历
                            回溯，撤销处理结果                                               然后再继续for横向遍历的过程
                        }
                    }

    【回溯举例】先考虑一种简单情况，[1 2 3 4] n = 4 k = 2,预期结果应为[[1 2] [1 3] [1 4] [2 3] [2 4] [3 4]]
           ===============================================================
                                         [1 2 3 4]                                   for(横向遍历集合[1 2 3 4])
                     取1              取2             取3             取4               执行【依次取集合元素的操作】;
           ===============================================================           backTracking递归到【下一层】
                  [2 3 4]            [3 4]           [4]             [空]             for(横向遍历集合[2 3 4])
              取2    取3   取4      取3    取4         取4                              执行【依次取集合元素的操作】;
           ===============================================================           backTracking递归到【下一层】
            [1 2]   [1 3]  [1 4]  [2 3]   [2 4]     [3 4]                            走到叶子结点后，深度递归结束
                                                                                     开始逐步回溯，直到返回到根节点，
                                                                                     再深度递归下一个子树
                   6、回溯过程撤销操作的重要性
                   （1）考虑无回溯撤销操作：那么针对[2 3 4]，操作序列及结果如下（注意，递归到该结点说明上层已经取了1），
                       取2 --> path[1 2] --> 取3 -->path[1 2 3] --> 取4 -->path[1 2 3 4]
                   （2）添加回溯撤销操作：那么针对[2 3 4]，操作序列及结果如下，
                       取2 --> path[1 2]
                       撤销 --> path[1]
                       取3 --> path[1 3]
                       撤销 --> path[1]
                       取4 --> path[1 4]
                       撤销 --> path[1]
                       本层[2 3 4]遍历完，执行撤销操作，path[]
                       回溯到根结点 [1 2 3 4]，继续执行取 2 操作，此时path[2]
                   （3）精髓就是，从上一层到下一层是递归深度遍历，从下一层回到上一层执行撤销操作

 */

import java.util.ArrayList;
import java.util.Collections;
import java.util.LinkedList;
import java.util.List;

public class Combine {
    // 步骤1：定义容器收集符合条件的结果
    // 递归深度遍历一个子树，暂存每一层中被取出的元素
    LinkedList<Integer> path = new LinkedList<>();
    // 当递归深度遍历到子树的叶子结点时，path存储的是最终符合条件的结果，
    // 后续path还需要存储下一个子树遍历路径上的值，所以需要另一个容器存储符合条件的path
    List<List<Integer>> result = new LinkedList<>();

    public List<List<Integer>> combine(int n, int k) {
        int startIndex = 1;
        backTracking1(n, k, 1);
        return result;
    }

    // 步骤1：确定回溯函数参数和返回值值
    //      形参：考虑递归过程中结点[1 2 3 4] -->[2 3 4]，每次执行操作后的新集合都需要新的起始坐标
    //      例如：[1 2 3 4] startIndex = 0, [2 3 4]相当于[1 2 3 4] startIndex = 1
    //      返回值：结果被收集在容器中，容器定义成成员变量，就不需要返回了,否则需要作为形参传入函数
    public void backTracking(int n, int k, int startIndex){
        // 步骤2：确定回溯函数终止条件
        // 如果走到叶子结点，则单棵子树的结果收集完成
        if(path.size() == k){
            result.add(new LinkedList<>(path));
            // 走到这里子树的深度递归就结束了，开始了函数逐步退栈，并回溯，再退栈，再回溯的过程
            return;
        }
        // 步骤3：确定回溯函数的单层处理逻辑
        // 考虑具体的例子更好书写，一般选择中间层，可以充分的考虑对上层和下层的影响
        // 对上层考虑需要返回什么值码？对下层就是继续递归，只是需要考虑递归的参数变化，可能需要对传入递归的参数做预处理
        // 本题考虑，对[2 3 4]结点，做处理，遍历的初始位置相当于[1 2 3 4] startIndex = 1
        for (int i = startIndex; i <= n; i++) {
            // 处理本层结点，即取数
            path.offerLast(i);
            // 无需向上层返回数据，那么继续遍历下一层
            // 考虑每依次递归，从[1 2 3 4]到[2 3 4]需要更新startIndex，所以递归参数需要更新startIndex
            backTracking(n, k, i+1);
            // 执行撤销操作
            path.removeLast();
        }
        // 补充 path就相当于一个栈

        // 坑：result.add(new LinkedList<>(path)); √
        //    result.add(path);错
        // 将path保存到result中需要生成新的对象，暂存path值，
        // 避免后续return后执行回溯撤销操作，修改path值，导致result中path被篡改
    }

    // 【剪枝优化】
    // 考虑针对[1 2 3 4] 当startIndex = 4 时，取4，剩余集合为空，这个分支其实应该被减掉
    // 也就是说startIndex 在 K = 2，的情况下，如果进行剪枝优化，取值范围是 1 ~ 3，其实没有必要取到 n = 4
    // 这样就可以减少 for 循环遍历次数，本质上是把集合中那些凑不够k个元素的孩子结点剔除
    // 那么如何确定 循环变量 i 在遍历结点集合时的终点在哪里？
    // 当遍历到树中某一个结点集合时，要保证【结点集合剩余元素（还没被取出的元素）个数 + 已路径收集的元素个数 >= k
    //      （1）结点集合剩余元素（还没被取出的元素）个数 = n - i + 1（左闭右开）
    //          例如：[1 2 3 4] 若 for 遍历到 i = 2 位置，那么集合剩余元素为 3 个，即[2 3 4]
    //      （2）已路径收集的元素个数 = path.size();
    //      （3）n - i + 1 + path.size() >= k  ===> i <= n + 1 - (k - path.size())
    //          例如：n = 4 , k = 3 当startIndex = 1，path.size() = 0 , i <= 2
    //          即：[1 2 3 4] 满足k = 3 for i的范围是[1,2]，如果 i = 3，那么只剩下[3 4]，是不符合k长度的
    public void backTracking1(int n, int k, int startIndex){
        if(path.size() == k){
            result.add(new LinkedList<>(path));
            return;
        }
        for (int i = startIndex; i <= (n + 1 - (k - path.size())); i++) {
            path.offerLast(i);
            backTracking(n, k, i+1);
            path.removeLast();
        }
    }
}
