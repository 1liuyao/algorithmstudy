package dynamic.algorithm.baseproblem;
/*
    【62 不同路径】: 一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。
                机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。
                问总共有多少条不同的路径？
    【示例 1】
            输入：m = 3, n = 7
            输出：28
    【示例 2】
            输入：m = 3, n = 2
            输出：3
            解释：
            从左上角开始，总共有 3 条路径可以到达右下角。
            1. 向右 -> 向下 -> 向下
            2. 向下 -> 向下 -> 向右
            3. 向下 -> 向右 -> 向下
    【示例 3】
            输入：m = 7, n = 3
            输出：28
    【示例 4】
            输入：m = 3, n = 3
            输出：6
    ============================================================
    【解题思路】动态规划
             举例：m = 3 , n = 7
                            j
             1    1    1    1    1    1    1
         i   1    2    3    4    5    6    7
             1    3    6    10   15   21   28

             1、确定 dp[i][j] 的含义：表示从起点 [0, 0] 到 [i, j]有 dp[i][j]条路径
             2、确定递推公式：到达[i, j]有两条途径， 左侧结点向右走 + 上侧结点向下走
                           dp[i][j] = dp[i - 1][j] + dp[i][j - 1]
             3、dp 数组初始化：第一行由于只能一直向右走才能得到，所以只有一条路径，第一行每一格都是 1
                            第一列由于只能一直向下走才能得到，所以只有一条路径，第一列每一格都是 1
                            其他格子初始化成任何值都可以，都会被迭代计算的新值覆盖
             4、确定遍历顺序：只需要保证 dp[i][j] 计算时，左侧和上侧都是更新过的新值就可以
                           所以先遍历 m 还是先遍历 n ，即先行遍历还是列遍历都可以，因为一开始左侧和上侧都被初始化过了

                           那么，可以倒叙遍历吗？
                           不可以，比如对行倒序，先遍历第三行，此时第二行还没更新过，计算的值是错误的，会比实际的值小，缺少了向下到达的路径数
                           如果先就算最后一列，那么同样的，左侧列还没有更新过，所以，缺少了向右到达的路径数
             5、需要打印 dp 数组：如果和上面手动计算结果一致，则正确，dp[m, n]存储的值就是最终的答案
 */
public class UniquePaths {
    public int uniquePaths(int m, int n) {
        // 第一步：初始化dp数组：表示从起点 [0, 0] 到 [i, j]有 dp[i][j]条路径
        int[][] dp = new int[m][n];

        // 第一行和第一列初始化为 1
        for (int i = 0; i < m; i++) {
            dp[i][0] = 1;
        }
        for (int j = 0; j < n; j++) {
            dp[0][j] = 1;
        }
        // 第二步：确定遍历顺序，迭代
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
            }
        }
        // 返回最终结果
        return dp[m -1][n - 1];
    }
}
