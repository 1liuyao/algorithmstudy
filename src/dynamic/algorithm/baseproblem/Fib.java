package dynamic.algorithm.baseproblem;

import java.util.ArrayList;

/*
    【509 斐波那契数】斐波那契数 （通常用 F(n) 表示）形成的序列称为 斐波那契数列 。
                   该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。
                   也就是： F(0) = 0，F(1) = 1
                          F(n) = F(n - 1) + F(n - 2)，其中 n > 1
                   给定 n ，请计算 F(n) 。

    【用例1】
            输入：n = 2
            输出：1
            解释：F(2) = F(1) + F(0) = 1 + 0 = 1
    【用例2】
            输入：n = 3
            输出：2
            解释：F(3) = F(2) + F(1) = 1 + 1 = 2
    【用例3】
            输入：n = 4
            输出：3
            解释：F(4) = F(3) + F(2) = 2 + 1 = 3
     ==========================================================================
     【动态规划】
        1、动态规划，英文：Dynamic Programming，简称DP，如果某一个问题有很多重叠子问题，使用动态规划是最有效的。
        2、对于动态规划问题，我将拆解为如下五步曲，这五步都搞清楚了，才能说把动态规划真的掌握了！
            （1）确定dp数组（dp table）以及下标的含义
            （2）确定递推公式
            （3）dp数组如何初始化
            （4）确定遍历顺序
            （5）举例推导dp数组
        3、动态规划应该如何debug：
            找问题的最好方式就是把dp数组打印出来，看看究竟是不是按照自己思路推导的！

     【解题思路】例如：0 1 1 2 3 5 8 13 ...
        1、确定dp数组（dp table）以及下标的含义：dp[i]表示第i个斐波那契数的值
        2、确定递推公式： dp[i] = dp[i - 1] + dp[i - 2]
        3、dp数组如何初始化：dp[0] = 0; dp[1] = 1;
        4、确定遍历顺序：若想知道第 i 个斐波那契数值，一定要知道前两个数，那么后面数的计算依赖前面的数，所以需要从前向后遍历
        5、举例推导dp数组：dp[0] = 0
                        dp[1] = 1
                        dp[2] = dp[1] + dp[0] = 0 + 1 = 1
                        dp[3] = dp[2] + dp[1] = 1 + 1 = 2
                        dp[4] = dp[3] + dp[2] = 2 + 1 = 3

 */
public class Fib {
    public int fib(int n) {
        if (n == 0)
            return 0;
        if (n == 1)
            return 1;
        // 步骤1：定义dp数组，dp[i]表示第i个斐波那契数的值
        ArrayList<Integer> dp = new ArrayList<>();
        // 步骤2：初始化dp数组：虽然分析 dp 如何初始化需要依赖地推公式，但是代码书写顺序需要先初始化 dp 数组
        // 注意：数组索引需要从 0 开始，斐波那契数列的 f(n) 也是从 f(0) 开始
        dp.add(0, 0);
        dp.add(1, 1);
        // 步骤3：确定遍历顺序
        for (int i = 2; i <= n; i++) {
            // 确定递推公式
            dp.add(i, dp.get(i - 1) + dp.get(i - 2)) ;
        }
        return dp.get(n);
    }
}
