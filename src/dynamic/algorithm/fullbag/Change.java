package dynamic.algorithm.fullbag;
/*
    【完全背包理论】
                1、定义：相比 01 背包，完全背包每一个物品可以放进背包无限次
                2、递推公式：滚动数组
                for(int i = 0; i < weight.size(); i++) { // 遍历物品
                    for(int j = weight[i]; j <= bagWeight ; j++) { // 遍历背包容量
                        dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
                    }
                }
               （1）01背包考虑倒叙遍历背包容量 是 为了保证每个物品只放进背包一次，若想每个物品放入背包多次，可以选择正序遍历背包容量
               （2）在 01 背包滚动数组中，物品和背包容量的遍历顺序不可以改变，但是完全背包可以调换遍历顺序，可以打印 dp 数组验证
               （3）普通版本的完全背包所求：装满背包容量为 bagWeight 的背包，最大价值是多少？
    ===========================================================================================================
    【518 零钱兑换 II】给你一个整数数组 coins 表示不同面额的硬币，另给一个整数 amount 表示总金额。
                     请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 0 。
                     假设每一种面额的硬币有无限个。
                     题目数据保证结果符合 32 位带符号整数。
    【示例 1】
            输入：amount = 5, coins = [1, 2, 5]
            输出：4
            解释：有四种方式可以凑成总金额：
            5=5
            5=2+2+1
            5=2+1+1+1
            5=1+1+1+1+1
    【示例 2】
            输入：amount = 3, coins = [2]
            输出：0
            解释：只用面额 2 的硬币不能凑成总金额 3 。
    【示例 3】
            输入：amount = 10, coins = [10]
            输出：1
    ========================================================================================================
    【解题思路】求组合数：每个物品可以放入背包多次，求装满背包 amount 有几种方法
            （1）dp[j] 数组含义：装满背包容量为 j 的背包共有 dp[j] 种方法
            （2）递推公式：求装满背包有几种方法，递推公式都是累加式的，和之前 FindTargetSumWays 推导递归公式的思路是一致的
                将物品 0 - i-1 依次放入背包： dp[j] = dp[j] + dp[j - coins[i]]
            （3）组合问题遍历顺序：先遍历物品，再遍历背包，保证物品按顺序装入：即装入 1 2，就不会装入 2 1
                for(int i = 0; i < weight.size(); i++) { // 遍历物品
                    for(int j = weight[i]; j <= bagWeight ; j--) { // 遍历背包容量
                        dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
                    }
                }
            （4）排列问题遍历顺序：先遍历背包再遍历物品，物品放入的顺序无法保证：即装入 1 2，也可以装入 2 1
                // 先遍历背包，再遍历物品
                for(int j = 0; j <= bagWeight; j++) { // 遍历背包容量
                    for(int i = 0; i < weight.size(); i++) { // 遍历物品
                        if (j - weight[i] >= 0) dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
                    }
                }
            （5）初始化： dp[0] = 1 // 题目描述模糊无法推断初始值，但题目测试用例中给出的如上
            （6）打印 dp 数组
 */
public class Change {
    public int change(int amount, int[] coins) {
        // dp[j] 数组含义：装满背包容量为 j 的背包共有 dp[j] 种方法
        int[] dp = new int[amount + 1];
        // 初始化
        dp[0] = 1;
        // 遍历顺序
        for (int i = 0; i < coins.length; i++) {
            for (int j = coins[i]; j <= amount; j++) {
                // 迭代
                dp[j] = dp[j] + dp[j - coins[i]];
            }
        }
        return dp[amount];
    }
}
