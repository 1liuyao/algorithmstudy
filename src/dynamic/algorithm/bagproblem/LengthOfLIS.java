package dynamic.algorithm.bagproblem;

import java.util.Arrays;

/*
    【300 最长递增子序列】给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。
                       子序列 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。
                       例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。

    【示例 1】
            输入：nums = [10,9,2,5,3,7,101,18]
            输出：4
            解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。
    【示例 2】
            输入：nums = [0,1,0,3,2,3]
            输出：4
    【示例 3】
            输入：nums = [7,7,7,7,7,7,7]
            输出：1
     ====================================================================================
    【解题思路】
            1、思考：如果手工统计不连续的递增子序列会怎么做？ nums = [10,9,2,5,3,7,101,18]
              （1）以 10 为递增序列最后一个元素，则连续递增元素个数为 1  [10]
              （2）以 9 为递增序列最后一个元素，则连续递增元素个数为 1  [9]
              （3）以 2 为递增序列最后一个元素，则连续递增元素个数为 1  [2]
              （4）以 5 为递增序列最后一个元素，依次遍历 5 之前的元素，找到比自己小的元素 2，则连续递增元素个数为 2  [2 5]
              （5）以 3 为递增序列最后一个元素，依次遍历 3 之前的元素，找到比自己小的元素 2，则连续递增元素个数为 2  [2 3]
              （6）以 7 为递增序列最后一个元素，依次遍历 7 之前的元素，
                  找到比自己小的元素 2，则连续递增元素个数为 1 + 1  [2 7]
                  找到比自己小的元素 5，则连续递增元素个数为 2 + 1  [2 5 7]
                  找到比自己小的元素 3，则连续递增元素个数为 2 + 1  [2 3 7]
                  取最大值，则以 7 为递增序列最后一个元素，连续递增元素个数为 3
              （7）以 101 为递增序列最后一个元素，依次遍历 101 之前的元素，
                  找到比自己小的元素 10，则连续递增元素个数为 1 + 1  [10 101]
                  找到比自己小的元素 9，则连续递增元素个数为 1 + 1  [9 101]
                  找到比自己小的元素 2，则连续递增元素个数为 1 + 1  [2 101]
                  找到比自己小的元素 5，则连续递增元素个数为 2 + 1  [2 5 101]
                  找到比自己小的元素 7，则连续递增元素个数为 3 + 1  [2 3 7 101]
                  取最大值，则以 101 为递增序列最后一个元素，连续递增元素个数为 4
              （8）总结：以数组中的每一个元素作为序列的结尾，依次遍历数组之前的元素
                       如果找到了比自己小的元素，则递增序列长度需要更新
                       更新规则：判断以比自己小的元素为结尾的递增序列元素个数 + 1，和以自己本身为结尾的递增元素个数做比较，取大者
              （9）注意：针对整个数组来说，最大递增子序列长度不一定出现 dp 数组的最后，
                       可能在中间，即以 101 结尾的递增序列长度是最大的，并不是以 18 结尾的递增序列长度

            2、定义 dp[i] 数组：以 nums[i] 元素为结尾，递增子序列的最大长度
            3、确定递推公式：dp[i] = max(dp[i], dp[j] + 1) if dp[j] < dp[i] , 其中 j 从 0 到 i - 1
            4、初始化 dp 数组：单个元素递增子序列为 1 ，dp数组全部初始化为1;
            5、遍历顺序：（1）i 的遍历顺序：从 0 到 nums.length - 1
                       （2）j 的遍历顺序：从 0 到 i - 1 ，当然倒叙也行

 */
public class LengthOfLIS {
    public int lengthOfLIS(int[] nums) {
        // 定义 dp[i] 数组：以 nums[i] 元素为结尾，递增子序列的最大长度
        int[] dp = new int[nums.length];
        // 初始化：单个元素递增子序列为 1 ，dp数组全部初始化为1
        for (int i = 0; i < nums.length; i++) {
            dp[i] = 1;
        }

        // 确定遍历顺序
        for (int i = 1; i < nums.length; i++) {
            // 遍历 i 之前的元素，和 i 比较，更新递增子序列的最大长度
            for (int j = 0; j < i ; j++) {
                if (nums[j] < nums[i])
                    dp[i] = Math.max(dp[j] + 1, dp[i]);
            }
            printArray(dp);
        }
        // 最大值可能不是最后一个元素
        int max = 0;
        for (int i = 0; i < nums.length; i++) {
            if (dp[i] > max)
                max = dp[i];
        }
        return max;
    }

    public void printArray(int[] array){
        for (int i = 0; i < array.length; i++) {
            System.out.print(array[i]);
        }
        System.out.println();
    }
}
