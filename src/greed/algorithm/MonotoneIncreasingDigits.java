package greed.algorithm;
/*
    【738 单调递增的数字】当且仅当每个相邻位数上的数字 x 和 y 满足 x <= y 时，我们称这个整数是单调递增的。
                      给定一个整数 n ，返回 小于或等于 n 的最大数字，且数字呈 单调递增 。
    【示例 1】
            输入: n = 10
            输出: 9
    【示例 2】
            输入: n = 1234
            输出: 1234
    【示例 3】
            输入: n = 332
            输出: 299
    ====================================================================================
    【解题思路】
            332
            从后向前遍历，  32   降序， 3 - 1 = 2， 变成 29
            继续向前遍历，  329  降序， 3 - 1 = 2， 变成 299

            规律：从后向前遍历，发现 降序，则 减 1，后面位变成 9

            1、为什么要从后向前遍历？
               若从前向后遍历， 332   33相等， 继续向后遍历， 32 降序，此时变成 329 不符合规则
            2、通过标记记录 从这一位开始减 1 后，后面每一位都变成 9
               3  3  2
                        |   一开始应该变成 9 的位置
                     |  发现 32 降序，所以变成 9 的位置向前移动
                  | 332 变成 329 后，32 仍然降序，所以变成 9 的位置需要向前移动

            3、为什么要记录变成 9 的位置，而不是发现降序，直接改成 9
               1000  从后向前遍历， 00 相等 不会发生 减1 和变 9 操作
               当遍历到 10，发现降序，则变成 900，不符合规则
 */
public class MonotoneIncreasingDigits {
    public int monotoneIncreasingDigits(int n) {
        String s = String.valueOf(n);
        char[] chars = s.toCharArray();
        // 初始需要变成 9 的位置在末尾，认为 暂时 没有任何一个位置需要变成 9
        int flag = chars.length;
        // 倒序遍历
        for (int i = chars.length - 1; i > 0 ; i--) {
            // 如果出现降序
            if (chars[i] < chars[i - 1]){
                chars[i - 1]--;
                flag = i;
            }
        }

        // 更新 9 的位置
        for (int i = flag; i < chars.length; i++) {
            chars[i] = '9';
        }

        return Integer.valueOf(String.valueOf(chars));
    }
}
