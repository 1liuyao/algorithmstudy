package stack.algorithm;

import java.util.Stack;

/*
    【42 接雨水】给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。

    【示例 1】
            输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]
            输出：6
            解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。
    【示例 2】
            输入：height = [4,2,0,3,2,5]
            输出：9
    ==========================================================================================
    【解题思路】
                           |
            |              |
            |        |     |
            |  |     |  |  |
            |  |     |  |  |
     索引    0  1  2  3  4  5

            ----------
                    0|       索引 0 元素入栈
            ----------
            ----------
                  1 0|       索引 1 元素高度小于索引 0 元素高度，直接入栈
            ----------
            ----------
                2 1 0|       索引 2 元素高度小于索引 1 元素高度，直接入栈
            ----------
            ----------
                2 1 0|       索引 3 元素高度大于索引 2 元素高度，横向计算矩形面积
            ----------       高 * 宽 = (min(索引 3 高度 , 索引 1 高度) - 索引 2 高度) * (3 - 1 - 1) = 2
            ----------
                  1 0|       索引 2 出栈，继续比较，索引 3 元素高度大于索引 1 元素高度，横向计算矩形面积 = 1 * (3 - 0 - 1) = 2
            ----------
            ----------
                  3 0|       索引 1 出栈，索引 3 继续和索引 0 比较，小于 直接入栈
            ----------
            ----------
                4 3 0|       索引 4 元素高度小于索引 3 元素高度，直接入栈
            ----------
            ----------
                4 3 0|       索引 5 元素高度大于索引 4 元素高度，横向计算矩形面积 = 1 * (5 - 3 - 1) = 1
            ----------
            ----------
                  3 0|       索引 4 出栈，继续比较，索引 5 元素高度大于索引 3 元素高度，横向计算矩形面积 = 1 * (5 - 0 - 1) = 4
            ----------
            ----------
                    0|       索引 3 出栈，继续比较，索引 5 元素高度大于索引 0 元素高度，由于计算高度需要获得栈顶下一个元素，此时栈内只剩一个
            ----------       元素，无法计算矩形面积
            ----------
                    0|       索引 0 出栈 ，索引 5 入栈，最终可接雨水面积 = 2 + 2 + 1 + 4 = 9
            ----------

            1、单调栈是单调递增还是单调递减？
              由于要获得 右侧第一个比自己大的元素，所以需要使用单调递增栈

            2、栈内应该存储什么元素？
              因为要通过 索引 计算 矩形宽度，所以栈内存储 元素索引

            3、单调栈入栈出栈策略
            （1）如果遍历元素 小于 栈顶元素，入栈
            （2）如果遍历元素 等于 栈顶元素，先出栈，再入栈，因为我们要求宽度的时候 如果遇到相同高度的柱子，需要使用最右边的柱子来计算宽度。
                |  |     |
                |  |  |  |   索引 1 和索引 0 元素高度相同，但是计算 高度时，需要选择 索引 1 和 索引 3，
                0  1  2  3   因此当遍历元素和栈顶元素高度相同时，需要先出栈，即把左侧列出栈，再把当前遍历元素入栈，保留右侧列
            （3）如果遍历元素 大于 栈顶元素，则 横向 计算雨水面积
                横向所接雨水面积 = (min(当前遍历元素高度, 栈顶下一个元素高度) - 栈顶元素高度) * (当前遍历元素索引 - 栈顶下一个元素 - 1)

            4、注意对栈的判空处理
 */
public class Trap {
    public int trap(int[] height) {
        int sum = 0;

        Stack<Integer> stack = new Stack<>();
        stack.push(0);

        for (int i = 1; i < height.length; i++) {
            if (height[i] < height[stack.peek()])
                stack.push(i);
            else if (height[i] == height[stack.peek()]){
                stack.pop();
                stack.push(i);
            }else{
                while(!stack.isEmpty() && height[i] > height[stack.peek()]){
                    // 底部高度
                    int mid = stack.pop();
                    // 注意判空处理，如果站内不存在两个元素，则无法计算面积
                    if (!stack.isEmpty()){
                        // 雨水高度
                        int waterHeight = Math.min(height[i], height[stack.peek()]) - height[mid];
                        // 雨水宽度
                        int waterWeigth = i - stack.peek() - 1;
                        sum = sum + waterHeight * waterWeigth;
                    }
                }
                stack.push(i);
            }
        }

        return sum;
    }
}
