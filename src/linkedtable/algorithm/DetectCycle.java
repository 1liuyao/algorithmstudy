package linkedtable.algorithm;
/*
    【142 环形链表 II】给定一个链表的头节点  head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。
                     如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。
                     为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。
                     如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。
                     不允许修改链表。
    【用例1】
        输入：head = [3,2,0,-4], pos = 1
        输出：返回索引为 1 的链表节点
        解释：链表中有一个环，其尾部连接到第二个节点。
    【用例2】
        输入：head = [1,2], pos = 0
        输出：返回索引为 0 的链表节点
        解释：链表中有一个环，其尾部连接到第一个节点。
    【用例3】
        输入：head = [1], pos = -1
        输出：返回 null
        解释：链表中没有环。
     ===============================================================================================
     【解决方案】快慢指针
              fast：步长为2  fast = fast.next.next
              slow：步长为1  slow = slow.next
                           环入口
              ---------------*-------
                             |      |
                             |--*---|     、
                          fast与slow相遇点
        1、什么情况下链表有环？
        如果链表没有环，那么慢指针和快指针永远不会相遇，因此如果快慢指针能够相遇，则说明链表有环，并且快慢指针一定是在环中相遇。
        2、如何确定快指针要多快，慢指针要多慢？
           考虑快指针与慢指针的速度差大于1，那么可能出现快指针在快追上慢指针时，存在跨越现象。
           如果速度差为1，在有环的情况下，快慢指针一定会在环中某点相遇
        3、如何找到环入口
          （1）从头结点到环入口的距离为 x
          （2）从环入口到 fast 与 slow 相遇点的距离为 y
          （3）从 fast 与 slow 相遇点再次到环入口的距离为 z
          （5）什么时候快慢指针会初次相遇呢？
              ①我们假设慢指针在环中走了很多圈才和快指针相遇，由于快指针的速度是慢指针的2倍，
               当慢指针走满一圈快指针一定走了两圈的距离，那么中间一定相遇了两次，也就是说快慢指针初次相遇时，慢指针一定未走满一圈
              ②快指针在与快指针初次相遇时，能否走多圈？
               当x相对长，圈相对小时，快指针先进入圈后，快指针走了很多圈，慢指针才入圈，这种情况是合理的
               注意：由于快指针先入圈，所以至少得走完一圈才能以扣圈的形式追上后入圈的慢指针
          （5）根据快慢指针速度推导距离关系式：
              因为，快指针的速度是慢指针的2倍
              所以，初次相遇时，快指针走的距离等于慢指针走的距离
              即， x + y + n(y+z) = 2 (x + y)
              化简，n(y + z) = x + y
                   (n - 1)(y + z) + z = x ，其中，n表示快指针走的圈数，n >= 1
           （6）考虑当距离满足什么样的关系，才能和环入口有关
               当 n = 1时，即快指针走了一圈后追上了慢指针
               可得，z = x
               因此，当快慢指针相遇后，如果一个指针从head开始走，一个指针从相遇点向入口走，并且步长均为1，
               则两指针一定会在入口相遇，则这个相遇的点就是环的入口
 */
public class DetectCycle {
    class ListNode {
        int val;
        ListNode next;

        ListNode(int x) {
            val = x;
            next = null;
        }
    }
    public ListNode detectCycle(ListNode head) {
        // 步骤1：初始化快慢指针,以及两个打了等步长指针
        ListNode fast = head;
        ListNode slow = head;

        ListNode index1 = head;
        ListNode index2;
        // 步骤2：判断链表是否有环，即判断快慢指针是否相遇
        // 循环判断条件是保证fast.next.next不出现空指针
        while (fast != null && fast.next != null){
            fast = fast.next.next;
            slow = slow.next;
            // 如果快慢指针相遇则说明有环,并保存
            if (fast == slow) {
                // 步骤3：寻找环入口
                index2 = fast;
                while (index1 != index2){
                    index1 = index1.next;
                    index2 = index2.next;
                }
                // 当两指针相遇时，index1和index2指向的结点即为入口结点
                return index1;
            }
        }
        // 如果fast指针为空，则证明没有环，是一个尾结点指向null的链表，而不是尾结点指向链表中结点的带环链表
        return null;
    }
}
